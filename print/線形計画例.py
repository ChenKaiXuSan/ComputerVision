from gurobipy import *

#各工場の生産可能な製品produce（工場数：10，製品種類：10）
produce = {1:[10],  2:[1,2,8,9], 3:[2,3,9], 4:[1,3,4,7,9,10], 5:[5,8,9],
           6:[6,7,8], 7:[1,2,3,6,7,9,10], 8:[4,5], 9:[6,7], 10:[8,9]}

#顧客iのk製品の需要量d
d = {(1,1):80, (1,2):85, (1,3):300, (1,4):6, (1,5):80, 
     (1,6):85, (1,7):300, (1,8):6, (1,9):900, (1,10):60,
     
     (2,1):270, (2,2):160, (2,3):400, (2,4):7, (2,5):70, 
     (2,6):95, (2,7):400, (2,8):5, (2,9):800, (2,10):160,
     
     (3,1):250, (3,2):130, (3,3):350, (3,4):4, (3,5):60, 
     (3,6):105, (3,7):500, (3,8):4, (3,9):700, (3,10):160,
     
     (4,1):160, (4,2):60, (4,3):200, (4,4):3, (4,5):50, 
     (4,6):115, (4,7):600, (4,8):3, (4,9):600, (4,10):360,
     
     (5,1):180, (5,2):40, (5,3):150, (5,4):5, (5,5):40, 
     (5,6):125, (5,7):700, (5,8):2, (5,9):500, (5,10):460
     }

#顧客の集合
I = set([i for (i,k) in d])

#各工場の生産容量
J,M = multidict({1:3000, 2:3500, 3:4000, 4:4500, 5:5000,
                 6:6000, 7:5500, 8:7000, 9:2000, 10:2500})

#各製品の重量
K,weight = multidict({1:1, 2:2, 3:3, 4:4, 5:5,
                      6:5, 7:4, 8:3, 9:2, 10:1})

#単位重量当たりの輸送費用（工場jから顧客iまで）
cost = {(1,1):4, (1,2):6, (1,3):9, (1,4):4, (1,5):6,
        (1,6):4, (1,7):6, (1,8):9, (1,9):4, (1,10):6,
        (2,1):5, (2,2):4, (2,3):7, (2,4):4, (2,5):6,
        (2,6):4, (2,7):6, (2,8):9, (2,9):4, (2,10):6,
        (3,1):6, (3,2):3, (3,3):4, (3,4):4, (3,5):6,
        (3,6):4, (3,7):6, (3,8):9, (3,9):4, (3,10):6,
        (4,1):8, (4,2):5, (4,3):3, (4,4):4, (4,5):6,
        (4,6):4, (4,7):6, (4,8):9, (4,9):4, (4,10):6,
        (5,1):10, (5,2):8, (5,3):4, (5,4):4, (5,5):6,
        (5,6):4, (5,7):6, (5,8):9, (5,9):4, (5,10):6
        }

#輸送費用の計算
c = {}
for i in I:
    for j in J:
        for k in produce[j]:
            c[i, j, k] = cost[i, j] * weight[k]

#説明変数の定義
model = Model("multi-commodity transportation")
x = {}
for i, j, k in c:
    x[i, j, k] = model.addVar(vtype="C")
model.update()

#制約条件
#（1）
for i in I:
    for k in K:
        model.addConstr(quicksum(x[i,j,k] for j in J
                                 if (i,j,k) in x) == d[i,k])
#（2）
for j in J:
    model.addConstr(quicksum(x[i,j,k] for (i,j2,k) in x
                             if j2 == j) <= M[j])

#目的関数の定義
model.setObjective(quicksum(c[i,j,k]*x[i,j,k] for (i,j,k) in x),
                   GRB.MINIMIZE)

#最適化問題を解く
model.optimize()
print ("Optimal value:", model.ObjVal)

#最適解をアウトレット
data=open('output_x.txt','w')   
print(x,file=data)
data.close()

# =============================================================================
#  arcs = tumplelist([(i,j,k) for (i,j,k) in x])
#
#  for i in I:
#      for k in K:
#          model.addConstr(
#                  quicksum(x[i,j,k] for (i,j,k)
#                  in arcs.select(i,"*",k)) == d[i,k])
#
#  for j in J:
#      model.addConstr(
#              quicksum(x[i,j,k] for (i,j,k)
#              in arcs.select("*",j,"*")<=M[j])
#
# =============================================================================
